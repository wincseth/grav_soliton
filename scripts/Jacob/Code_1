import numpy as np
import matplotlib.pyplot as plt
#global variables should be all caps
n = 10 # steps
DELTA = 1/(n+1) # finite difference?
ZETA = np.linspace(1, 10, n) #initializing ZETA values
ZETA_S = 0.01 #initialized from some eigenvalues
G = 6.7*10**(-39) #normalized gravity
M_PL = 1 / np.sqrt(G) #mass of plank mass
M = 8.2*10**10 #if a equals the atomic Bohr radius
#a = 1 /(G*M**3)#gravitational bohr radius
R_S = 2*G*M #schwarzschild radius

#g00 = 1 - ZETA/ZETA_S #time metric in terms of ZETA's
#grr = 1/g00 #radial metric in terms of ZETA's
level = 0#array of lambda
loops = 6

def metric(A, B):
    '''perameters: 1-d array for A & B returns: 1-d array for g00 & grr'''
    g00 = np.exp(2*A) #time metric
    grr = np.exp(2*B) #radial metric
    return g00, grr

def KG_values(g00, grr, A_array):
    '''parameters: g00 and grr are inputed as a 1-d array'''
    H = (ZETA_S**2)/(4*(ZETA**2)*(ZETA**2 - ZETA_S**2))  # this is h_~"/h_~ = H
    C = (-(g00/grr)*H + (4/ZETA_S)*np.exp(A_array)*np.sinh(A_array) + 2*((g00/grr)/(DELTA**2)))#matrix component
    D = -(g00/grr)/(DELTA**2)#matrix component
    return C, D

def KG_matrix(C, D):
    '''initalizes matrix'''
    matrix = np.zeros((n,n))#setting a nxn matrix all zero meshgrid
    for i in range(n):    
        matrix[i,i] = C[i]
        if i < n - 1:
            matrix[i, i+1] = D[i]
        if i > 1:
            matrix[i, i-1] = D[i]
            
    return matrix

def KG_solver(matrix):
    '''returns: epsilon and lmabda as floats, u_bar is a 1-d array'''
    e_vals, e_vecs = np.linalg.eig(matrix)#e_vals are lamdas, e_vecs are ubars
    print("lambda= ", e_vals)
    print("u_bar= ", e_vecs)
    lamda = e_vals[level]
    u_bar = e_vecs[:, level]#selects a whole coloumn
    epsilon = lamda/(1 + np.sqrt(1 + (ZETA_S*lamda)/2))
    
    return [epsilon, lamda, u_bar]

def h_tilde(g00, grr):
    '''h_tilde is an array'''
    h_tilde = ZETA**np.sqrt(np.sqrt(g00/grr))
    return h_tilde

def R_tilde(g00, u):
    '''input is an array and output is an array'''
    R_tilde = np.sqrt(g00)*u / ZETA**2
    return R_tilde

def dR_tilde(R):
    '''input is an array and output is an array '''
    dR_tilde = np.zeros(len(R))
    for i in range(len(R)):
        if i == n-1 or i == 0:
            dR_tilde[i] = 0
            continue
        dR_tilde[i] = (R[i+1] - R[i-1])/(2*DELTA)
    return(dR_tilde)

def temp_slope(zeta, R, dR, g00, grr, e):
    '''all input except e are an array
    return an array of dA's and dB's '''
    if zeta == 0:
        dA = 0
        dB = 0
        #print("zeta = ", zeta)
    elif zeta != 0:
        dA = (grr-1)/(2*zeta) - (ZETA_S*zeta*grr*R**2)/4 + ((ZETA_S**2)*zeta/8)*(dR)**2 + (ZETA_S*zeta/4)*(1+(ZETA_S*e)/2)**2 * (grr/g00) * (R)**2
        dB = -(grr-1)/(2*zeta) + (ZETA_S*zeta*grr*R**2)/4 + ((ZETA_S**2)*zeta/8)*(dR)**2 + (ZETA_S*zeta/4)*(1+(ZETA_S*e)/2)**2 * (grr/g00) * (R)**2
    return dA, dB

def R_K(R, dR, e, g00, grr):
    '''parameters all arrays except e
    #return two arrays A's and B's'''
    A = np.zeros(n)
    B = np.zeros(n)
    for i in range(len(R)-1):
        if i == 0:
            dA = 0
            dB = 0
        else:
            dA = A[i] + DELTA*temp_slope(ZETA[i], R[i], dR[i], g00[i], grr[i], e)[0]
            dB = B[i] + DELTA*temp_slope(ZETA[i], R[i], dR[i], g00[i], grr[i], e)[1]
            
        A[i+1] = A[i] + (DELTA/2)*(dA - A[i] + temp_slope(ZETA[i + 1], R[i + 1], dR[i + 1], g00[i + 1], grr[i + 1], e)[0])
        B[i+1] = B[i] + (DELTA/2)*(dB - B[i] + temp_slope(ZETA[i + 1], R[i + 1], dR[i + 1], g00[i + 1], grr[i + 1], e)[1])
    return [A, B]

def main():
    A_array = np.zeros(n) #dynamic variables
    B_array = np.zeros(n) #dynamic variables
    
    for i in range(loops):#e= epsilon, u = ubar
        g00, grr = metric(A_array, B_array)
        C,D = KG_values(g00, grr, A_array)#j= epsilon, k= e_vec
        matrix = KG_matrix(C, D)
        e, j, u = KG_solver(matrix)
        R = R_tilde(g00, u)
        dR = dR_tilde(R)
        print("zeta",ZETA )
        print("grr= ", grr)
        print("g00= ",g00)
        print("R_tilde", R)
        print("dR_tilde", dR)
        print("epsilon =", e)
        print("lamda =", j)#prints e_values
        print("u_bar =", u)#prints e_vectors
        A_array, B_array = R_K(R, dR, e, g00, grr)
        print("grr= ", grr)
        print("g00= ",g00)
        print("A= ", A_array[n-1], "B= ", B_array[n-1], "e= ", e)
    
_ = main()